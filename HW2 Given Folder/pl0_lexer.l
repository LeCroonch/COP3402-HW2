/* $Id: pl0_lexer_definitions_top.l,v 1.2 2023/10/06 11:12:37 leavens Exp leavens $ */
/* Lexical Analyzer for PL/0 */

%option header-file = "pl0_lexer.h"
%option outfile = "pl0_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"
#include "pl0.tab.h"

/* Tokens generated by Bison */
#define VAR 270
#define CONST 269
#define PROCEDURE 271
#define CALL 272
#define END 274
#define IF 275
#define THEN 276
#define ELSE 277
#define WHILE 278
#define DO 279
#define ASSIGNOP 268
#define SEMICOLON 265
#define COMMA 267
#define PERIOD 264
#define LEQOP 286
#define NEQOP 284
#define LTOP 285
#define GEQOP 288
#define GTOP 287
#define PLUSOP 260
#define MINUSOP 261
#define TIMESOP 262
#define DIVOP 263
#define IDENT 258
#define NUMBER 259
#define BEGIN 273

/* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* Have any errors been noted? */
bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

 /* you can add actual definitions below */


 /* the rules section starts after the %% below */

%%

"var" {
	tok2ast(VAR);
	return VAR;
}

"const" {
	tok2ast(CONST);
	return CONST;
}

"procedure" {
	tok2ast(PROCEDURE);
	return PROCEDURE;
}

"call" {
	tok2ast(CALL);
	return CALL;
}

"begin" {
	tok2ast(BEGIN);
	return BEGIN;
}

"end" {
	tok2ast(END);
	return END;
}

"if" {
	tok2ast(IF);
	return IF;
}

"then" {
	tok2ast(THEN);
	return THEN;
}

"else" {
	tok2ast(ELSE);
	return ELSE;
}

"while" {
	tok2ast(WHILE);
	return WHILE;
}

"do" {
	tok2ast(DO);
	return DO;
}

":=" {
	tok2ast(ASSIGNOP);
	return ASSIGNOP;
}

";" {
	tok2ast(SEMICOLON);
	return SEMICOLON;
}

"," {
	tok2ast(COMMA);
	return COMMA;
}

"." {
	tok2ast(PERIOD);
	return PERIOD;
}

"<=" {
	tok2ast(LEQOP);
	return LEQOP;
}

"<>" {
	tok2ast(NEQOP);
	return NEQOP;
}

"<" {
	tok2ast(LTOP);
	return LTOP;
}

">=" {
	tok2ast(GEQOP);
	return GEQOP;
}

">" {
	tok2ast(GTOP);
	return GTOP;
}

"+" {
	tok2ast(PLUSOP);
	return PLUSOP;
}

"-" {
	tok2ast(MINUSOP);
	return MINUSOP;
}

"*" {
	tok2ast(TIMESOP);
	return TIMESOP;
}

"/" {
	tok2ast(DIVOP);
	return DIVOP;
}


[a-zA-Z_][a-zA-Z0-9_]* {
	/* Identifiers */
	ident2ast(yytext);
	return IDENT;
}

[0-9]+ {
	/* Numbers */
	unsigned int val = atoi(yytext);
	if (val > UINT_MAX) {
		fprintf(stderr, "%s:%d: Number %s exceeds the maximum allowed value\n", filename, yylineno, yytext);
		return YYerror;
	}
	number2ast(val);
	return NUMBER;
}


[ \t\n\r] { /* Ignore whitespace */ }

. { /* Unrecognized character */
	fprintf(stderr, "%s:%d: Unrecognized character: %s\n", filename, yylineno, yytext);
	errors_noted = true;
}
%%




/* This code goes in the user code section of the pl0_lexer.l file,
   following the last %% above. */

// Requires: fname != NULL
// Requires: fname is the name of a readable file
// Initialize the lexer and start it reading
// from the given file name
void lexer_init(char *fname)
{
    errors_noted = false;
    yyin = fopen(fname, "r");
    if (yyin == NULL) {
	bail_with_error("Cannot open %s", fname);
    }
    filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
        }
        lexer_print_token(t, yylineno, yytext);
    } while (t != YYEOF);
}

int main()
{
	
}
